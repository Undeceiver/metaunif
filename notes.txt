When meta-variables are in a root equivalence class, we need to enumerate them. However, we know that they need to include only variables of the unifier level at which they are (including base, where it's just the input variables), and that it needs to be such that the graph contains no cycles at any level (which indicate an occurs check).

When inverting a unifier on a meta-variable, where the unifier is not fully described, there also needs to be an enumeration, based on the value of uC (inductively). For example, if uC = f(g(x),y), then C may be either a variable z itself such that u z = f(g(x),y), or it may be f(z1,z2), for two variables z1, z2 such that u z1 = g(x) and u z2 = y, or it may be f(g(z1),z2), for two variables z1, z2. There are no more possibilities, and for each of these, we can check which variables are possible in each place, and give these as a set of both solutions to the meta-variable and to the unifier. 

Solutions cannot be obtained through vertical dependencies, BUT, the graph needs to be updated, including propagation. In essence, this corresponds to taking the target of the vertical dependency, changing it to something more precise, but still a meta-term/literal, and propagate.

DEPRECATED: Transitivity of propagation with vertical dependencies is strange. When I get to know that ux = y, I also know that vux = vy, and that wvux = wvy, but while the first propagation took a term to a meta-term, the second one took a meta-term to a meta-term. This essentially tells us how to update dependents when a vertical dependency is updated. For the dependency vux -> wvux; before, I knew that if vux = t, then wvux = wt. We don't yet know what vux is, but we know that it is equal to vy (which is more precise). We can conclude that wvux = wvy. Essentially, we had a function Term -> Metaterm, which we know will remain equal. That is, if vux = t, then wvux = wt; so if vy = t, then wvy = t; AND we also want to obtain the meta-term wvy. This is done by carefully separating the unifiers before the updated dependency vy, and then placing them back, and using the existing dependency. vux went to vy. Find the inner term, and keep the unifiers separated: Unifiers are "v", and term is "y". Now, apply the dependency to "y", to obtain "wy", but we forgot the unifiers, so separate again into "w" and "y", and put the unifiers inbetween: "wvy".

The way that we build them, vertical dependencies always consist on adding one unifier, so we know that to update the dependents we just take the outer-most unifier and replace the inner part. If the meta-term / literal is not a variable, the dependency function may need to be updated. In order to do this in general, what we will do is to re-build the horizontal constraints in which the target dependent of the vertical dependency is involved from the dependencies, update them with the new meta-term, simplify the resulting constraints, and then remove the dependent from the graph and add all the resulting constraints to the graph.

